#!/usr/bin/env perl

# parses at least 3 kinds of lines with dates
#
# Intent:  be able to sort (ie, "|sort")  a number of different events in a stream
#  (git logs, .file-log, and history file times) 
#  by normalizing them all and putting the data at BOL in a simple number format
#
# -- so reordering rules to make others come after.
#
# could e extended to add rules for e.g.  using cues in output to determine when a command is run
#  (ls output, shell prompts, etc)
#  ..  though that is not the intent, it's a possible use case

use strict;
use Date::Manip qw(ParseDate UnixDate);

my $date = 0;
my $TSTDEBUG = $ENV{'TSTDEBUG'};
#print "DEBUG is $TSTDEBUG\n";

while (<>) {
  # Mon Aug  1 12:38:10 EDT 2016  (with timezone)
  if ( / (\w.. .\d \d\d:\d\d:\d\d ..T \d\d\d\d)/ ) {
    $date = ParseDate($1); 
    $date .= ' [rule wt]' if $TSTDEBUG;
  }
  # 1469839409 - Fri Jul 29 20:43:29 EDT 2016
  if ( /(1[45]\d\d\d\d\d\d\d\d)/ ) {
    $date = UnixDate("epoch $1", "%O");
    $date = ParseDate($date); 
    $date .= ' [rule ue]' if $TSTDEBUG;
  }

  #    2015-08-03 21:01:59 
#  if ( /(\d\d\d\d-\d\d-\d\d \d\d:\d\d:\d\d)/ ) { 
  # also +/- TZ offset
  if ( /(\d\d\d\d-\d\d-\d\d \d\d:\d\d:\d\d( [-+]\d\d\d\d)?)/ ) { 
    $date = ParseDate($1); 
    $date .= "\t[rule tzo:$1]" if $TSTDEBUG;  ## TODO others like this
  }
  # Mon Aug  3 14:19:45 2015   (emacs file-log)
  if ( / (\w.. .\d \d\d:\d\d:\d\d \d\d\d\d)/ ) {
    $date = ParseDate($1);
    $date .= ' [rule efl]' if $TSTDEBUG;
  }

  if ( $date ) {
    print "$date\t$_";
  } else {
    print;
  }  
}
